# CloudHomomorphicEncryption
The goal of this project was to implement a simple circuit that runs on homomorphically encrypted ciphertext. The imagined scenario is between a client Alice, and a remote server that we refer to as the cloud. Alice creates and encrypts two files and sends them to the cloud to be stored. The only reference to the files that Alice possesses are the file names. Alice is then able to request the contents of either (or both) of the files by making an encrypted request. The cloud runs the circuit with Alice‚Äôs query and returns the requested file, all while remaining unaware of the name or contents of the file that is returned. Due to the restrictions of homomorphic encryption, a message is encrypted one bit at a time, so the files that Alice creates are of a single bit. In our simple scenario, there are two files, 0 and 1 where the contents of each file are the same as their file names. Note that while the contents of the files and the names of the file share the same value, both the file content and file name encrypt to their own unique ciphertexts. The query for the files will also have a unique ciphertext.

## Description of Implementation
The entirety of the project was created using the Java programming language. The creation, encryption, and decryption of the files can be found in the Data.java file. The Alice.java file contains the communications to and from the cloud to both store and request the files. The Cloud.java class contains the functions that run the requested circuits to return the correct files in response to an encrypted query. The source code for these files can be found in Appendix B. Due to the size of the integers, it was necessary to make use of Java‚Äôs BigInteger class to store the file names and contents. The communication between Alice and the cloud is entirely simulated by function calls between the two classes. The Alice class is responsible for calling the creation, encryption and decryption methods for the Data objects. This class is also responsible for sending the Data objects to the cloud as well as creating and sending the encrypted queries. The Cloud class stores the files provided by the Alice class, runs the selection circuit with the provided query and returns the file. The Cloud class maintains neither record of the file that was requested nor the contents of said file. The Data class is an object that simulates a file. It has a file identifier as well as a value representing its contents. The Data class contains all methods necessary for the encryption and decryption of a Data object.
## Requesting A File
The cloud stores the encrypted names of the files as well as the encrypted contents of the files. For a file request, the cloud receives the encrypted name of the file from Alice and runs the designated circuit to fetch the corresponding file. Recall that the ciphertext generation scheme DGHV (Section 2) will produce different ciphertexts for the same encrypted message, so the name of the file ‚Äò0‚Äô will be encrypted to a different value from the encrypted query used to fetch file ‚Äò0‚Äô. The circuit implements the following pseudocode:
            ```
            if file A is requested
                  send file A
            else
            ```
send file B
If we let Q represent the Boolean value of ‚Äúfile A is requested‚Äù, then we can simplify this to ‚Äúif Q then A else B‚Äù. This can be expressed in Boolean logic as (A AND Q) XOR (B AND NOT Q). Since the encryption scheme only allows us to use XOR and AND gates, the equivalent of the NAND gate is employed to determine the result of NOT Q. The circuit is now (A AND Q) XOR (B AND ( 1 XOR (Q AND Q)). The encrypted value that was received with the file request query is assigned to Q. Since there are only two values, if the circuit evaluates to 0, the second file B was the request; and if the circuit evaluates to 1, then A is the requested file. The full proof of this can be seen in Appendix A. In this way, the circuit will not know which specific file was requested and sent back.
## Requesting One of Four Files
To operate with four files, and ideally with any n number of files, the circuit described in the above section ‚Äì circuit ùõº ‚Äì is run multiple times. In the case of four files, ùõº is run thrice. The input to the circuits is determined as follows. Firstly, for reference, the files are labelled as A, B, C, D, and their values are one of 00, 01, 10, and 11. A requirement of the circuit is that it operate on single bits of differing values. So, an XOR operation is performed between the most
significant bit of A and B. If the most significant bits of A and B are equal, then the circuit ùõº is run first with A and C, and then with B and D. If the most significant bits of A and B are not equal then the circuit ùõº is run with A and B, and then with C and D. The first ‚Äòround‚Äô of the ùõº circuit will select between each pair, which produces two files ‚Äì X and Y ‚Äì whose most significant bits match that of the query Q. The circuit ùõº is run once more with files X and Y; however, the least significant bits of the file identifiers are used instead. 
